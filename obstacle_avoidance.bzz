
### BUZZ FUNCTIONS ##
include "include/vec2.bzz"

UPPERTHRESHOLD = 0.9
LOWERTHRESHOLD = 0.1
PIAPPROX = 3.14159

# Calculates the sum of the proximity readings
function prox_sum(rid, data, accum){
    return math.vec2.add(math.vec2.newp(data.value, data.angle), accum)
}

# Test code for Buzz syntax
function my_prox_sum(accum){
    accum = math.vec2.newp(0.0, 0.0)
    var l = size(proximity)
    for (i = 0, i < l, i = i + 1){
        math.vec2.add(math.vec2.newp(proximity[i].value, proximity[i].angle), accum)
    }
    return accum
}

function init() {
  # variable used to determine whether new behavior is an improvement on the situation
  mythresh = LOWERTHRESHOLD
}


function step() {
    # sum of proximity readings
    var accum = reduce(proximity, prox_sum, math.vec2.newp(0.0, 0.0))
    
    # magnitude of accum vector
    var accumlen = math.vec2.length(accum)

    # half of range of angles to turn in
    var range = PIAPPROX*(1.0-accumlen)

    # angle to turn to var angle = math.rng.uniform(-1*range, range) centered on pi (backwards)
    var angle = math.rng.uniform(PIAPPROX - (range), PIAPPROX + range)
    
    # if below lower threshold keep going straight
    if (accumlen < LOWERTHRESHOLD)
        accum = math.vec2.newp(0.7, 0.0)
	
    # if at or above upper threshold turn directly away from the obstacle
    if (accumlen >= UPPERTHRESHOLD)
        #if (neighbors.count() > 0)
	    accum = math.vec2.new(-accum.x/math.vec2.length(accum), -accum.y/math.vec2.length(accum))
	    
    # if between thresholds turn away from the obstacle randomly, more if closer to upper threshold
    if (accumlen < UPPERTHRESHOLD)
        if (accumlen > LOWERTHRESHOLD)
            #if (neighbors.count() > 0)
	       	#log("range ", range)
	        accum = math.vec2.newp(0.5, angle)

    # if we're futher away then we were, run away
    if (accumlen <= mythresh)
        accum = math.vec2.newp(0.7, 0.0)

		mythresh = accumlen
    # move
    goto(accum.x, accum.y)
}


function reset() {
}

function destroy() {
}